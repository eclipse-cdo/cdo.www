<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="Release_Notes_CDO_3.0">Release Notes CDO 3.0</h1><p>This document elaborates on the <b>new and noteworthy</b> enhancements in CDO 3.0.<br/></p><ol style="list-style: none;"><li><a href="#Release_Notes_CDO_3.0">Release Notes CDO 3.0</a><ol style="list-style: none;"><li><a href="#User_Interface">User Interface</a></li><li><a href="#Core_Framework">Core Framework</a><ol style="list-style: none;"><li><a href="#Branching_and_merging_is_now_supported">Branching and merging is now supported</a></li><li><a href="#Offline_clones_are_now_supported">Offline clones are now supported</a></li><li><a href="#Legacy_models_are_now_supported">Legacy models are now supported</a></li><li><a href="#The_transient_modifier_of_an_EStructuralFeature_can_now_be_overridden_by_annotation">The transient modifier of an EStructuralFeature can now be overridden by annotation</a></li><li><a href="#The_session_API_to_determine_or_wait_for_remote_updates">The session API to determine or wait for remote updates</a></li><li><a href="#New_session_option_for_receiving_more_detailed_commit_infos">New session option for receiving more detailed commit infos</a></li><li><a href="#Reattached_objects_now_keep_their_original_identity">Reattached objects now keep their original identity</a></li><li><a href="#Push_transactions_have_been_introduced">Push transactions have been introduced</a></li><li><a href="#Changes_in_a_local_transaction_can_be_exported_and_imported">Changes in a local transaction can be exported and imported</a></li><li><a href="#Successful_commits_can_now_be_queried">Successful commits can now be queried</a></li><li><a href="#Better_type_support_for_queries">Better type support for queries</a></li><li><a href="#New_call-back_hook_after_object_state_changes">New call-back hook after object state changes</a></li><li><a href="#New_call-back_hook_after_branch_point_changes_of_a_view">New call-back hook after branch point changes of a view</a></li><li><a href="#New_call-back_hook_after_adapter_notification">New call-back hook after adapter notification</a></li><li><a href="#New_call-back_hook_after_successful_commits">New call-back hook after successful commits</a></li><li><a href="#New_API_to_distinguish_local_commits_from_remote_commits">New API to distinguish local commits from remote commits</a></li></ol></li><li><a href="#DB_Store">DB Store</a><ol style="list-style: none;"><li><a href="#New_alternative_mapping_strategy_for_increased_performance_for_particular_list_operations">New alternative mapping strategy for increased performance for particular list operations</a></li><li><a href="#New_model_annotations_are_available_to_override_mapping_defaults">New model annotations are available to override mapping defaults</a></li><li><a href="#External_references_are_now_supported">External references are now supported</a></li><li><a href="#Feature_maps_are_now_supported">Feature maps are now supported</a></li><li><a href="#Unsettable_Features_are_now_supported_properly">Unsettable Features are now supported properly</a></li><li><a href="#SQL_is_now_supported_as_a_query_language">SQL is now supported as a query language</a></li></ol></li><li><a href="#Hibernate_Store">Hibernate Store</a><ol style="list-style: none;"><li><a href="#Documentation_has_been_completed">Documentation has been completed</a></li><li><a href="#Example_projects_added">Example projects added</a></li><li><a href="#HQL_is_supported_as_a_query_language">HQL is supported as a query language</a></li><li><a href="#Teneo_extension_mechanism_support_added">Teneo extension mechanism support added</a></li><li><a href="#External_references_are_supported">External references are supported</a></li><li><a href="#Feature_Map_support_has_been_added">Feature Map support has been added</a></li></ol></li></ol></li></ol><p>Alternatively you can query Bugzilla directly to list</p><ul><li><a href="https://bugs.eclipse.org/bugs/buglist.cgi?field0-0-0=flagtypes.name;bug_severity=enhancement;resolution=FIXED;classification=Modeling;query_based_on=NEEDS_DOC;query_format=advanced;bug_status=RESOLVED;version=3.0;type0-0-0=notequals;value0-0-0=documentation%2B;component=CDO;component=Net4j;product=EMF;known_name=NEEDS_DOC">Enhancements not described in this document</a></li><li><a href="https://bugs.eclipse.org/bugs/buglist.cgi?bug_severity=enhancement;resolution=FIXED;classification=Modeling;query_based_on=NEEDS_DOC;query_format=advanced;bug_status=RESOLVED;version=3.0;component=CDO;component=Net4j;product=EMF;known_name=NEEDS_DOC">All enhancements</a></li><li><a href="https://bugs.eclipse.org/bugs/buglist.cgi?bug_severity=blocker;bug_severity=critical;bug_severity=major;bug_severity=normal;bug_severity=minor;bug_severity=trivial;resolution=FIXED;classification=Modeling;query_based_on=NEEDS_DOC;query_format=advanced;bug_status=RESOLVED;version=3.0;component=CDO;component=Net4j;product=EMF;known_name=NEEDS_DOC">All bugs</a></li></ul><h2 id="User_Interface">User Interface</h2><h2 id="Core_Framework">Core Framework</h2><h3 id="Branching_and_merging_is_now_supported">Branching and merging is now supported</h3><p>Branches form an explicit, navigable tree in CDO. It is managed by a session's CDOBranchManager, which also emits CDOBranchCreatedEvent for local and remote branch creation.</p><pre>
    CDOBranch mainBranch = session.getBranchManager().getMainBranch();
    CDOBranch team1Branch = mainBranch.createBranch("team1", timeStamp);

    CDOTransaction transaction = session.openTransaction(team1Branch);
    CDOView view = session.openView(team1Branch, team1Branch.getBase().getTimeStamp());
    view.setBranchPoint(mainBranch.getHead());
</pre><p><br/>
Merging is also supported through the new merge(CDOBranchPoint source, CDOMerger merger) method in CDOTransaction. There are several default implementations of the CDOMerger interface provided. An interactive merger will be provided soon.</p><p><img width="480" border="0" src="MergeConcepts.png"/></p><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=270716">270716</a>.</p><h3 id="Offline_clones_are_now_supported">Offline clones are now supported</h3><p>You need to setup a normal repository as the master. Then you setup a second one via CDOServerUtil.createOfflineClone(String, IStore, Map&lt;String, String&gt;, IRepositorySynchronizer). Depending on the configuration of the synchronizer that you have to pass in  there are certain restrictions on the store type of the clone repo. The clone is a repository by itself and can be embedded it into a client or made available via TCP transport to many clients. So, it can also be used the clone like a "group server" to serve a subset of the overall clients. That speeds up reads but slows down writes a little bit, as commits are "write-through".</p><p><img width="480" border="0" src="OfflineOverview.png"/></p><p>For the clone creation you need a repository synchronizer. Use CDOServerUtil.createRepositorySynchronizer(CDOSessionConfigurationFactory). The synchronizer maintains a session to the master and tries to re-establish that session if the connection breaks down. See: IRepositorySynchronizer.setRetryInterval(int)</p><p>A clone repository has a state, one of OFFLINE, SYNCING, ONLINE. Reads are always served from the clone. commits are write-through if the clone is ONLINE. If the clone is not ONLINE, a commit from a client will create a new "local" branch (or offline branch) on the fly. Your client app will always have to check the CDOCommitInfo that is returned from tx.commit(). The branch in the info can be different from the branch of the local tx. In that case it usually makes sense to switch the local tx to the newly created offline branch and adjust the UI accordingly. You will also have to persist that branch info locally, so that you can use that branch after client restarts.</p><p>After an OFFLINE phase of the clone repo the synchronizer enters an intermediary SYNCING state and fetches new changesets. After syncing everything the clone transitions back to ONLINE. now your app can merge up from the offline branch and commit the result to the master (write-through).</p><p>There are 2 different replication mechanisms in the synchronizer:</p><ul><li>The normal one analyzes the original changesets in the master, transports them over the network (much like a commit) and really calls a faked commit on the clone. So the original commits are really recreated. This mechanism currently just requires the two stores to use the same CDOID *type*, e.g. MEMStore and DBStore would be possible at the same time, one in the master, one in the clone. The drawback is that it is quite slow, especially if you have lots of small commits.</li></ul><ul><li>We provided a "raw replication" mode in the synchronizer. That one streams the store content directly from one store to the clone store on a low level. It's extremely fast but requires the two stores to be identical. We could replicate 200MB in less then 15 seconds over the network.</li></ul><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=256936">256936</a>.</p><h3 id="Legacy_models_are_now_supported">Legacy models are now supported</h3><p>Legacy models from a CDO perspective are those that have not been regenerated to support all CDO features natively.
These models are now supported by CDO, although they do not support lazy loading and unloading of their instances.
The legacy mode has to be enabled explicitely for new transactions/views:</p><pre>
    // Enable legacy support from now on for all views that will be opened by this thread
    CDOUtil.setLegacyModeDefault(true);

    CDOView view = session.openView();
    System.out.println("Legacy model support: " + view.isLegacyModeEnabled());
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=247226">247226</a>.</p><h3 id="The_transient_modifier_of_an_EStructuralFeature_can_now_be_overridden_by_annotation">The transient modifier of an EStructuralFeature can now be overridden by annotation</h3><p>Sometimes you want to use transient/persistent modifiers for particular structural features in
CDO repositories that differ from the normal (XML) behaviour. The following annotation constants have
been added to EMFUtil:</p><pre>
      public static final String CDO_ANNOTATION_SOURCE = "http://www.eclipse.org/emf/CDO";
      public static final String CDO_ANNOTATION_KEY_PERSISTENT = "persistent";
</pre><p><br/>
Their literals can be used in an Ecore model definition as follows:</p><pre>
      &lt;eClassifiers xsi:type="ecore:EClass" name="Product1"&gt;
        &lt;eStructuralFeatures xsi:type="ecore:EAttribute" name="description" eType="..." transient="true"&gt;
          &lt;eAnnotations source="http://www.eclipse.org/emf/CDO"&gt;
            &lt;details key="persistent" value="true"/&gt;
          &lt;/eAnnotations&gt;
        &lt;/eStructuralFeatures&gt;
      &lt;/eClassifiers&gt;
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=290990">290990</a>.</p><h3 id="The_session_API_to_determine_or_wait_for_remote_updates">The session API to determine or wait for remote updates</h3><p>A getLastUpdateTime() method has been added to CDOSession. With the new waitForUpdate() methods
in CDOSession you can, e.g., synchronize local views and transactions.</p><pre>
    final CDOCommitInfo commitInfo = transaction.commit();

    new Thread()
    {
      @Override
      public void run()
      {
        session.waitForUpdate(commitInfo.getTimeStamp());
      }
    }.start();
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=283947">283947</a>.</p><h3 id="New_session_option_for_receiving_more_detailed_commit_infos">New session option for receiving more detailed commit infos</h3><p>A session can now be configured to receive full revision deltas instead of just invalidation keys.</p><pre>
    session.options().setPassiveUpdateMode(PassiveUpdateMode.CHANGES);
    session.addListener(new IListener()
    {
      public void notifyEvent(IEvent event)
      {
        if (event instanceof CDOSessionInvalidationEvent)
        {
          CDOSessionInvalidationEvent e = (CDOSessionInvalidationEvent)event;
          for (CDORevisionKey key : e.getChangedObjects())
          {
            CDORevisionDelta revisionDelta = (CDORevisionDelta)key;
            System.out.println("Feature deltas: " + revisionDelta.getFeatureDeltas());
          }
        }
      }
    });
</pre><p><br/>
A session can now be configured to receive full new revisions instead of only keys.</p><pre>
    session.options().setPassiveUpdateMode(PassiveUpdateMode.ADDITIONS);
    session.addListener(new IListener()
    {
      public void notifyEvent(IEvent event)
      {
        if (event instanceof CDOSessionInvalidationEvent)
        {
          CDOSessionInvalidationEvent e = (CDOSessionInvalidationEvent)event;
          for (CDOIDAndVersion key : e.getNewObjects())
          {
            CDORevision revision = (CDORevision)key;
            System.out.println("Container of new object: " + revision.data().getContainerID());
          }
        }
      }
    });
</pre><p><br/>
PassiveUpdateMode.ADDITIONS includes PassiveUpdateMode.CHANGES.<br/>
The default option is PassiveUpdateMode.INVALIDATIONS.<br/>
Note that the CDOSessionInvalidationEvent interface extends CDOCommitInfo.</p><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=294528">294528</a>.</p><h3 id="Reattached_objects_now_keep_their_original_identity">Reattached objects now keep their original identity</h3><p>Formerly objects that were first being detached from a transaction and then
being reattached to the same transaction were assigned a new identitiy.
That was annoying in use cases like drag and drop in a user interface.
Now the transaction remembers identities of detached objects and reassigns them if needed.</p><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=294528">294528</a>.</p><h3 id="Push_transactions_have_been_introduced">Push transactions have been introduced</h3><p>The new push transactions support commits to local files. Later the changes can be read from this local file and pushed to a repository.</p><pre>
    File file = new File("changes.bin");
    file.delete();

    // Open a new transaction and wrap it in a push transaction
    CDOPushTransaction transaction1 = new CDOPushTransaction(session.openTransaction(), file);

    // Commit to local file
    transaction1.commit();
    transaction1.close();

    // Open a new push transaction and load changes from local file
    CDOPushTransaction transaction2 = new CDOPushTransaction(session.openTransaction(), file);

    // Push changes to the repository
    transaction2.push();
    transaction2.close();
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=297967">297967</a>.</p><h3 id="Changes_in_a_local_transaction_can_be_exported_and_imported">Changes in a local transaction can be exported and imported</h3><p>The method exportChanges() has been added to CDOTransaction.</p><pre>
    OutputStream fos = new FileOutputStream("changes.bin");

    try
    {
      CDOSavepoint[] savepoints = transaction1.exportChanges(fos);
    }
    finally
    {
      IOUtil.close(fos);
    }
</pre><p><br/>
The method importChanges() has been added to CDOTransaction.</p><pre>
    InputStream fis = new FileInputStream("changes.bin");

    try
    {
      CDOSavepoint[] savepoints = transaction2.importChanges(fis, true);
    }
    finally
    {
      IOUtil.close(fis);
    }
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=298334">298334</a>.</p><h3 id="Successful_commits_can_now_be_queried">Successful commits can now be queried</h3><p>The concept of <i>successful commits</i> has been made explicit and queriable through CDOCommitInfoManager.</p><pre>
    CDOBranchManager branchManager = session.getBranchManager();
    CDOBranch mainBranch = branchManager.getMainBranch();

    CDOCommitInfoManager commitInfoManager = session.getCommitInfoManager();
    commitInfoManager.getCommitInfos(
        mainBranch,
        CDOBranchPoint.UNSPECIFIED_DATE,
        CDOBranchPoint.UNSPECIFIED_DATE,
        new CDOCommitInfoHandler()
        {
          public void handleCommitInfo(CDOCommitInfo commitInfo)
          {
            System.out.println("Commit comment: " + commitInfo.getComment());
          }
        });
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=256649">256649</a>.</p><h3 id="Better_type_support_for_queries">Better type support for queries</h3><p>Several small enhancements have been applied to query and query result transport:</p><ul><li>Query parameters can carry enum values instead of integer numbers, see bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=282610">282610</a>.</li><li>Query results carry enum values instead of integer numbers, see bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=283117">283117</a>.</li><li>Query results can carry arrays of primitive types, see bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=282612">282612</a>.</li></ul><h3 id="New_call-back_hook_after_object_state_changes">New call-back hook after object state changes</h3><p>Provides a way of being notified about state changes of objects.</p><pre>
    CDOView view = session.openView();
    view.addObjectHandler(new CDOObjectHandler()
    {
      public void objectStateChanged(CDOView view, CDOObject object, CDOState oldState, CDOState newState)
      {
        System.out.println("Object transitioned to " + newState);
      }
    });
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=292733">292733</a>.</p><h3 id="New_call-back_hook_after_branch_point_changes_of_a_view">New call-back hook after branch point changes of a view</h3><p>Provides a way of being notified about target changes of views.</p><pre>
    CDOView view = session.openView();
    view.addListener(new IListener()
    {
      public void notifyEvent(IEvent event)
      {
        if (event instanceof CDOViewTargetChangedEvent)
        {
          CDOViewTargetChangedEvent e = (CDOViewTargetChangedEvent)event;
          System.out.println("A new view target has been set: " + e.getBranchPoint());
        }
      }
    });

    view.setBranch(view.getSession().getBranchManager().getMainBranch());
    view.setTimeStamp(CDOBranchPoint.UNSPECIFIED_DATE);
    view.setBranchPoint(anotherView);
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=289880">289880</a>.</p><h3 id="New_call-back_hook_after_adapter_notification">New call-back hook after adapter notification</h3><p>Since adapter notification can cause side effects and the order of the
notifications is unpredictable a new event is emitted by views to indicate the end of a
notification series.</p><pre>
    CDOView view = session.openView();
    view.addListener(new IListener()
    {
      public void notifyEvent(IEvent event)
      {
        if (event instanceof CDOViewAdaptersNotifiedEvent)
        {
          CDOViewAdaptersNotifiedEvent e = (CDOViewAdaptersNotifiedEvent)event;
          System.out.println("All adapters have been notified about commit " + e.getTimeStamp());
        }
      }
    });
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=289880">289880</a>.</p><h3 id="New_call-back_hook_after_successful_commits">New call-back hook after successful commits</h3><p>Provides a way to handle transactions after they have been committed to the backend store.</p><pre>
    IRepository repository = CDOServerUtil.createRepository("myrepo", store, props);

    repository.addHandler(new IRepository.WriteAccessHandler()
    {
      public void handleTransactionBeforeCommitting(ITransaction transaction,
          IStoreAccessor.CommitContext commitContext, OMMonitor monitor) throws RuntimeException
      {
        System.out.println("About to commit " + transaction);
      }

      public void handleTransactionAfterCommitted(ITransaction transaction,
          IStoreAccessor.CommitContext commitContext, OMMonitor monitor)
      {
        System.out.println("Committed " + transaction);
      }
    });
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=304959">304959</a>.</p><h3 id="New_API_to_distinguish_local_commits_from_remote_commits">New API to distinguish local commits from remote commits</h3><p>An isRemote() method has been added to CDOSessionInvalidationEvent.</p><pre>
    session.addListener(new IListener()
    {
      public void notifyEvent(IEvent event)
      {
        if (event instanceof CDOSessionInvalidationEvent)
        {
          CDOSessionInvalidationEvent e = (CDOSessionInvalidationEvent)event;
          if (e.isRemote())
          {
            System.out.println("A remote session has committed a transaction: " + e.getUserID());
          }
        }
      }
    });
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=281566">281566</a>.</p><h2 id="DB_Store">DB Store</h2><h3 id="New_alternative_mapping_strategy_for_increased_performance_for_particular_list_operations">New alternative mapping strategy for increased performance for particular list operations</h3><p>The default mapping strategy for the audit-aware DBStore usually writes value lists (for many-valued
features) completely for each revision. The new mapping strategy type <code>horizontalAuditWithRanges</code>
uses a different approch: each list value is associated with a start and end revision indicating its
lifetime. For applications in which lists are mostly extended by adding elements to the end of the lists,
using this mapping strategy can lead to increased performance.</p><p>However, in cases where lists are rearranged, of if list entries in the middle of the list are removed regularly,
the default mapping should still be the better choice. Also, as of now, this strategy can not be used together
with the new branching feature.</p><p>To activate the alternative mapping strategy, use the following configuration setting in the server's configuration.xml:</p><pre>
&lt;store type="db"&gt;
  &lt;mappingStrategy type="horizontalAuditWithRanges"&gt;
    &lt;property name="qualifiedNames" value="false"/&gt;
  &lt;/mappingStrategy&gt;
  ...
&lt;/store&gt;
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=296440">296440</a>.</p><h3 id="New_model_annotations_are_available_to_override_mapping_defaults">New model annotations are available to override mapping defaults</h3><p>The following new annotations are now recognized by the DBStore:</p><pre>
    public enum DBAnnotation
    {
      TABLE_MAPPING("tableMapping"),
      TABLE_NAME("tableName"),
      COLUMN_NAME("columnName"),
      COLUMN_TYPE("columnType"),
      COLUMN_LENGTH("columnLength");

      public final static String SOURCE_URI = "http://www.eclipse.org/CDO/DBStore";
    }
</pre><p><br/>
In CDO a structural feature can have multiple annotation with the same source, like:</p><pre>
    &lt;eStructuralFeatures xsi:type="ecore:EAttribute" name="value"
                eType="ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString"&gt;
      &lt;eAnnotations source="http://www.eclipse.org/CDO/DBStore"&gt;
        &lt;details key="columnName" value="HOLY"/&gt;
      &lt;/eAnnotations&gt;
      &lt;eAnnotations source="http://www.eclipse.org/CDO/DBStore"&gt;
        &lt;details key="columnType" value="CLOB"/&gt;
      &lt;/eAnnotations&gt;
    &lt;/eStructuralFeatures&gt;
</pre><p><br/>
See bugzillas <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=284701">284701</a>, <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=282976">282976</a>, <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=284680">284680</a>.</p><h3 id="External_references_are_now_supported">External references are now supported</h3><p>External references are created if an object managed by a transaction refers to an object
that is either not managed by a view or is managed by a view to a different repository.
Internally such references are represented by instances of CDOIDExternal and their
CDOID.isExternal() method always returns true. In the database they appear as negative long values,
indicating that the URI of the target object can be looked up in a separate table.</p><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=249610">249610</a>.</p><h3 id="Feature_maps_are_now_supported">Feature maps are now supported</h3><p>If your model contains feature maps you can now use the DBStore to persist them.</p><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=254455">254455</a>.</p><h3 id="Unsettable_Features_are_now_supported_properly">Unsettable Features are now supported properly</h3><p>For EStructuralFeatures which have the <code>unsettable</code> property set to <code>true</code>,
an additional boolean column is created in the corresponding database table which indicates if
the feature is set. If an unset feature is stored, <code>false</code> is stored in the additional
column and the feature's default value is stored in the feature's value field.</p><p>See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=284110">284110</a>.</p><h3 id="SQL_is_now_supported_as_a_query_language">SQL is now supported as a query language</h3><p>If you are aware of the structure and meaning of a DBStore created mapping schema you can now
use SQL to query the backend efficiently. Note that might need to consider version and/or branch information to prevent duplicate results from being returned.</p><pre>
    CDOQuery query = view.createQuery("sql", "SELECT CDO_ID FROM CUSTOMER ORDER BY NAME");
    List&lt;Customer&gt; customers = query.getResult(Customer.class);
</pre><p><br/>
See bugzilla <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=248933">248933</a>.</p><h2 id="Hibernate_Store">Hibernate Store</h2><h3 id="Documentation_has_been_completed">Documentation has been completed</h3><p>The documentation of the Hibernate store has been completed and is available on the <a href="http://wiki.eclipse.org/CDO_Hibernate_Store">CDO wiki</a>. The documentation includes a <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Quick_Start">quick start</a> and <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Start_Tutorial">tutorial</a>, an overview article on the <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Architecture">architecture</a>, <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Download_and_Install">download and install</a>, <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Model_Relational_Mapping">model relational mapping</a> specifics and details on the <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_HQL">HQL</a> support.</p><h3 id="Example_projects_added">Example projects added</h3><p>To ease the learning curve and facilitate starting with the Hibernate store <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Download_and_Install#Example_Projects">2 example development projects</a> have been created and are downloadable from cvs. The example projects show how to setup the server side and shows examples of querying and updating on the client using the CDO-Hibernate store.</p><h3 id="HQL_is_supported_as_a_query_language">HQL is supported as a query language</h3><p>The Hibernate store now supports HQL on the client. Practically the complete HQL syntax is supported:</p><ul><li>paged queries</li><li>parameterized queries</li><li>queries with functions</li><li>queries which return primitive valued objects (not only CDOObjects)</li></ul><p>In addition asynchronous queries are supported.</p><p>For more information on the HQL support see <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_HQL">this</a> wiki page.</p><h3 id="Teneo_extension_mechanism_support_added">Teneo extension mechanism support added</h3><p>The CDO Hibernate store supports the Teneo extension mechanism. This allows you to replace core parts of Teneo's mapping logic with your own implementation. See <a href="http://wiki.eclipse.org/CDO_Hibernate_Store_Model_Relational_Mapping#Teneo_Extensions">here</a> for more information.</p><h3 id="External_references_are_supported">External references are supported</h3><p>By using special the special @External annotation it is now possible to persist references to objects which are not persisted directly in the CDO Hibernate store. See <a href="http://wiki.eclipse.org/Teneo/Hibernate/ModelRelational/Association_Mapping#Storing_external_references_.28to_non-persisted_objects.29.2C_customizing_persisting_references">this Teneo documentation</a> for more information.</p><h3 id="Feature_Map_support_has_been_added">Feature Map support has been added</h3><p>Feature maps are now supported out-of-the-box. See <a href="http://wiki.eclipse.org/Teneo/Hibernate/XMLSchema/FeatureMap">this Teneo documentation</a> for a general discussion on featuremap support, the CDO Hibernate store supports a similar mechanism.</p></body></html>